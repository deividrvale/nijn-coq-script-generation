<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Proof_script (onijn.Coq.Proof_script)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">onijn</a> &#x00BB; <a href="../index.html">Coq</a> &#x00BB; Proof_script</nav><header class="odoc-preamble"><h1>Module <code><span>Coq.Proof_script</span></code></h1><p>This module provide specialized functionality for the generation of Coq proof scripts.</p><p>After parsing the output from a termination tool, <b>onijn</b> keeps all the information about the term rewriting system given as input.</p><p>The data needed to generate a proof script is therefore:</p><ul><li>Preamble declarations.</li><li>The list of sorts.</li><li>The list of symbols and their respective arities.</li><li>The declaration of each rule in the system.</li><li>The associative list of interpretation for each function symbol.</li></ul><p>Notice that up to the current version, <b>onijn</b> only produces proof scripts for polynomial interpretations. More functionality (adding support for more constructs) will be added when more termination techniques are supported.</p></header><nav class="odoc-toc"><ul><li><a href="#preamble-constructions">Preamble Constructions</a></li><li><a href="#sorts-and-types">Sorts and Types</a></li><li><a href="#function-symbols-and-arity">Function Symbols and arity</a></li><li><a href="#rules-and-rewriting">Rules and Rewriting</a></li><li><a href="#polynomial-interpretations">Polynomial Interpretations</a></li><li><a href="#termination-statement">Termination Statement</a></li></ul></nav><div class="odoc-content"><h2 id="preamble-constructions"><a href="#preamble-constructions" class="anchor"></a>Preamble Constructions</h2><div class="odoc-spec"><div class="spec type" id="type-import" class="anchored"><a href="#type-import" class="anchor"></a><code><span><span class="keyword">type</span> import</span><span> = <span>string list</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-scope" class="anchored"><a href="#type-scope" class="anchor"></a><code><span><span class="keyword">type</span> scope</span><span> = <span>string list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-import" class="anchored"><a href="#val-import" class="anchor"></a><code><span><span class="keyword">val</span> import : <span><a href="#type-import">import</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-scope" class="anchored"><a href="#val-scope" class="anchor"></a><code><span><span class="keyword">val</span> scope : <span><a href="#type-scope">scope</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><h2 id="sorts-and-types"><a href="#sorts-and-types" class="anchor"></a>Sorts and Types</h2><div class="odoc-spec"><div class="spec type" id="type-sort_dec" class="anchored"><a href="#type-sort_dec" class="anchor"></a><code><span><span class="keyword">type</span> sort_dec</span><span> = <span><a href="../../Syntax/Ty/Sort/index.html#type-t">Syntax.Ty.Sort.t</a> list</span></span></code></div><div class="spec-doc"><p>Sort declaration is a list of sorts.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sort_def_stm" class="anchored"><a href="#val-sort_def_stm" class="anchor"></a><code><span><span class="keyword">val</span> sort_def_stm : <span><a href="#type-sort_dec">sort_dec</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>sort_def_stm sdec</code> produces the coq string defining the inductive type for sorts.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sort_abrv" class="anchored"><a href="#val-sort_abrv" class="anchor"></a><code><span><span class="keyword">val</span> sort_abrv : <span><a href="#type-sort_dec">sort_dec</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>sort_abrv sdec</code> produces abbreviations for each sort. So the proof script becomes more human readable.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dec_eq_ty" class="anchored"><a href="#val-dec_eq_ty" class="anchor"></a><code><span><span class="keyword">val</span> dec_eq_ty : string</span></code></div><div class="spec-doc"><p><code>dec_eq_ty</code> is the statement of decidable equality for types.</p></div></div><h2 id="function-symbols-and-arity"><a href="#function-symbols-and-arity" class="anchor"></a>Function Symbols and arity</h2><div class="odoc-spec"><div class="spec type" id="type-fn_dec" class="anchored"><a href="#type-fn_dec" class="anchor"></a><code><span><span class="keyword">type</span> fn_dec</span><span> = <span><a href="../../Syntax/Term/index.html#type-fn">Syntax.Term.fn</a> list</span></span></code></div><div class="spec-doc"><p>The <b>signature</b> (in rewriting nomenclature) is the list (or set) of each funciton symbol present in the TRS.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fn_def_stm" class="anchored"><a href="#val-fn_def_stm" class="anchor"></a><code><span><span class="keyword">val</span> fn_def_stm : <span><a href="#type-fn_dec">fn_dec</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>fn_def_stm fn_dec</code> is the Coq statement defining each function symbol in <code>fn_dec</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-arity_def_stm" class="anchored"><a href="#val-arity_def_stm" class="anchor"></a><code><span><span class="keyword">val</span> arity_def_stm : <span><a href="#type-fn_dec">fn_dec</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>arity_def_stm fn_dec</code> is the Coq statement defining the arity, of each function symbol in <code>fn_dec</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fn_abrv" class="anchored"><a href="#val-fn_abrv" class="anchor"></a><code><span><span class="keyword">val</span> fn_abrv : <span><a href="#type-fn_dec">fn_dec</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>arity_def_stm fn_dec</code> abbreviates each fn_name in <code>fn_dec</code> and introduce them as a list of Definition statements in the proof script.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dec_eq_fn" class="anchored"><a href="#val-dec_eq_fn" class="anchor"></a><code><span><span class="keyword">val</span> dec_eq_fn : string</span></code></div><div class="spec-doc"><p><code>dec_eq_fn</code> is the Coq proof body that equality of</p></div></div><h2 id="rules-and-rewriting"><a href="#rules-and-rewriting" class="anchor"></a>Rules and Rewriting</h2><div class="odoc-spec"><div class="spec value" id="val-rules_def_stm" class="anchored"><a href="#val-rules_def_stm" class="anchor"></a><code><span><span class="keyword">val</span> rules_def_stm : <span><a href="../../Syntax/Rule/index.html#type-trs">Syntax.Rule.trs</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>rules_def_stm trs</code> is the Coq statement declaring each rewriting rule in the term rewriting system <code>trs</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-afs_df_stm" class="anchored"><a href="#val-afs_df_stm" class="anchor"></a><code><span><span class="keyword">val</span> afs_df_stm : <span><a href="../../Syntax/Rule/index.html#type-trs">Syntax.Rule.trs</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>afs_df_stm trs</code> is the Coq statement declaring the term rewriting system <code>trs</code> as a list of rules.</p></div></div><h2 id="polynomial-interpretations"><a href="#polynomial-interpretations" class="anchor"></a>Polynomial Interpretations</h2><div class="odoc-spec"><div class="spec value" id="val-itp_def_stm" class="anchored"><a href="#val-itp_def_stm" class="anchor"></a><code><span><span class="keyword">val</span> itp_def_stm : 
  <span><span><span>(<a href="../../Syntax/Term/index.html#type-fn">Syntax.Term.fn</a> * <a href="../../Syntax/Poly/index.html#type-poly_fun">Syntax.Poly.poly_fun</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>itp_def_stm itp trs_name</code> is the Coq statement declaring the interpretation of each funciton symbol in the the signature. The TRS is declared with the name <code>trs_name</code>.</p></div></div><h2 id="termination-statement"><a href="#termination-statement" class="anchor"></a>Termination Statement</h2><div class="odoc-spec"><div class="spec value" id="val-sn_def_stm" class="anchored"><a href="#val-sn_def_stm" class="anchor"></a><code><span><span class="keyword">val</span> sn_def_stm : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>sn_def_stm trs_name</code> is the Coq statement that the TRS <code>trs_name</code> is strongly normalizing.</p><p>This is the final step to build the proof script.</p></div></div></div></body></html>