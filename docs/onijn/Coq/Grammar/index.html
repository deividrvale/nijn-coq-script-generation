<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Grammar (onijn.Coq.Grammar)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">onijn</a> &#x00BB; <a href="../index.html">Coq</a> &#x00BB; Grammar</nav><header class="odoc-preamble"><h1>Module <code><span>Coq.Grammar</span></code></h1><p>This module provides functionality <b>onijn</b>'s &quot;compiler&quot;. We need to generate string constructs that can be parsed by Coq in order to generate a proof-script that can be checked. The functions in this module produce strings that satisfy the requirements in <a href="https://coq.inria.fr/distrib/current/refman/language/core/definitions.html">https://coq.inria.fr/distrib/current/refman/language/core/definitions.html</a>.</p><p>Notice that it is possible to produce coq code that doesn't compile in Coq. The production functions here only receive strings as input and produce strings matching Coq's grammar. Coq is the ultimate checker of the output of proof scripts.</p></header><nav class="odoc-toc"><ul><li><a href="#keywords">Keywords</a></li><li><a href="#grammar-constructions">Grammar Constructions</a></li></ul></nav><div class="odoc-content"><h2 id="keywords"><a href="#keywords" class="anchor"></a>Keywords</h2><div class="odoc-spec"><div class="spec type" id="type-keyword" class="anchored"><a href="#type-keyword" class="anchor"></a><code><span><span class="keyword">type</span> keyword</span><span> = </span></code><table><tr id="type-keyword.Require" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Require" class="anchor"></a><code><span>| </span><span><span class="constructor">Require</span></span></code></td></tr><tr id="type-keyword.Import" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Import" class="anchor"></a><code><span>| </span><span><span class="constructor">Import</span></span></code></td></tr><tr id="type-keyword.Open" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Open" class="anchor"></a><code><span>| </span><span><span class="constructor">Open</span></span></code></td></tr><tr id="type-keyword.Scope" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Scope" class="anchor"></a><code><span>| </span><span><span class="constructor">Scope</span></span></code></td></tr><tr id="type-keyword.Proof" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Proof" class="anchor"></a><code><span>| </span><span><span class="constructor">Proof</span></span></code></td></tr><tr id="type-keyword.Qed" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Qed" class="anchor"></a><code><span>| </span><span><span class="constructor">Qed</span></span></code></td></tr><tr id="type-keyword.Defined" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Defined" class="anchor"></a><code><span>| </span><span><span class="constructor">Defined</span></span></code></td></tr><tr id="type-keyword.Definition" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Definition" class="anchor"></a><code><span>| </span><span><span class="constructor">Definition</span></span></code></td></tr><tr id="type-keyword.Match" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Match" class="anchor"></a><code><span>| </span><span><span class="constructor">Match</span></span></code></td></tr><tr id="type-keyword.With" class="anchored"><td class="def variant constructor"><a href="#type-keyword.With" class="anchor"></a><code><span>| </span><span><span class="constructor">With</span></span></code></td></tr><tr id="type-keyword.End" class="anchored"><td class="def variant constructor"><a href="#type-keyword.End" class="anchor"></a><code><span>| </span><span><span class="constructor">End</span></span></code></td></tr><tr id="type-keyword.Let" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Let" class="anchor"></a><code><span>| </span><span><span class="constructor">Let</span></span></code></td></tr><tr id="type-keyword.In" class="anchored"><td class="def variant constructor"><a href="#type-keyword.In" class="anchor"></a><code><span>| </span><span><span class="constructor">In</span></span></code></td></tr><tr id="type-keyword.Global" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Global" class="anchor"></a><code><span>| </span><span><span class="constructor">Global</span></span></code></td></tr><tr id="type-keyword.Instance" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Instance" class="anchor"></a><code><span>| </span><span><span class="constructor">Instance</span></span></code></td></tr><tr id="type-keyword.Progam" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Progam" class="anchor"></a><code><span>| </span><span><span class="constructor">Progam</span></span></code></td></tr><tr id="type-keyword.Inductive" class="anchored"><td class="def variant constructor"><a href="#type-keyword.Inductive" class="anchor"></a><code><span>| </span><span><span class="constructor">Inductive</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The <code>keyword</code> type enumerates the keywords we support.</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-keyword_to_string" class="anchored"><a href="#val-keyword_to_string" class="anchor"></a><code><span><span class="keyword">val</span> keyword_to_string : <span><a href="#type-keyword">keyword</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>keyword_to_string k</code> is the written representation of <code>k</code> as in Coq syntax.</p></div></div><h2 id="grammar-constructions"><a href="#grammar-constructions" class="anchor"></a>Grammar Constructions</h2><div class="odoc-spec"><div class="spec value" id="val-ident_vbar" class="anchored"><a href="#val-ident_vbar" class="anchor"></a><code><span><span class="keyword">val</span> ident_vbar : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span>(string * string * string)</span> list</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>ident_vbar idt cs </code> returns a string in the grammar:</p><p><b><code>idt</code> | &lt;lhs_0&gt; &lt;token&gt; &lt;rhs_0&gt; ... <code>idt</code> | &lt;lhs_n&gt; &lt;token&gt; &lt;rhs_n&gt;</b>,</p><p>where <code>idt</code> is the identation string and the <b>&lt;lhs_i&gt; &lt;token&gt; &lt;rhs_i&gt;</b> are in <code>cs</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cmd_def" class="anchored"><a href="#val-cmd_def" class="anchor"></a><code><span><span class="keyword">val</span> cmd_def : <span><a href="#type-keyword">keyword</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>cmd_def keyword ident body</code> returns a string in the grammar:</p><p><b>&lt;keyword&gt; &lt;ident&gt; :=</b></p><p><b>&lt;body&gt; .</b></p><p>It can be used to define the identifier <code>ident</code> with the body <code>body</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cmd_stm" class="anchored"><a href="#val-cmd_stm" class="anchor"></a><code><span><span class="keyword">val</span> cmd_stm : <span>?keyword_list:<span><a href="#type-keyword">keyword</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-keyword">keyword</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>cmd_stm ~keyword_list:[ks] keyword body</code> returns a string in the grammar</p><p><b>&lt;<code>ks</code>&gt;? &lt;<code>keyword</code>&gt; &lt;<code>body</code>&gt;.</b></p><p><b>Example:</b> to produce the coq code <code>Require Import Nijn.</code>, we invoke <code>cmd_stm</code> as follows:</p><p><code>cmd_stm ~keyword_list[Require] Import &quot;Nijn&quot;</code>.</p><p>Notice that the optional argument <code>~keyword_list</code> is needed whenever the coq statement utilizes more than one keyword.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cmd_proof" class="anchored"><a href="#val-cmd_proof" class="anchor"></a><code><span><span class="keyword">val</span> cmd_proof : <span><a href="#type-keyword">keyword</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>cmd_proof keyword body</code> returns a string in the grammar</p><p><b>Proof.</b></p><p><b>&lt;proof_body&gt;</b></p><p><b><code>keyword</code>.</b></p><p>The <code>keyword</code> argument should be a valid proof ending Coq keyword (if you want to produce valid coq scripting). In this version: <a href="#type-keyword.Qed"><code>Qed</code></a> or <a href="#type-keyword.Defined"><code>Defined</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cmd_ind_dec" class="anchored"><a href="#val-cmd_ind_dec" class="anchor"></a><code><span><span class="keyword">val</span> cmd_ind_dec : 
  <span><a href="#type-keyword">keyword</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(string * string * string)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>cmd_ind_dec keyword ident ls</code> returns a string in the grammar</p><p><b><code>keyword</code> <code>ident</code> :=</b></p><p><b>|&lt;lhs_0&gt; &lt;token&gt; &lt;rhs_0&gt;</b></p><p><b>...</b></p><p><b>| &lt;lhs_n&gt; &lt;token&gt; &lt;rhs_n&gt;.</b></p><p>The list <code>ls</code> contains the list of triples representing the &lt;lhs&gt; &lt;token&gt; &lt;rhs&gt; pattern.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-match_cmd" class="anchored"><a href="#val-match_cmd" class="anchor"></a><code><span><span class="keyword">val</span> match_cmd : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>match_cmd match_ident body</code> returns a string in the grammar</p><p><b>match &lt;<code>match_ident</code>&gt; with</b></p><p><b>&lt;<code>body</code>&gt;</b></p><p><b>End</b></p></div></div><div class="odoc-spec"><div class="spec value" id="val-let_cmd" class="anchored"><a href="#val-let_cmd" class="anchor"></a><code><span><span class="keyword">val</span> let_cmd : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>let_cmd let_ident body</code> returns a string in the grammar</p><p><b>let &lt;<code>let_ident</code>&gt; := &lt;<code>body</code>&gt; in</b></p></div></div></div></body></html>