<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Term (onijn.Syntax.Term)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">onijn</a> &#x00BB; <a href="../index.html">Syntax</a> &#x00BB; Term</nav><header class="odoc-preamble"><h1>Module <code><span>Syntax.Term</span></code></h1><p>This module provides functionality for the notion of terms.</p></header><nav class="odoc-toc"><ul><li><a href="#function-symbols">Function Symbols</a></li><li><a href="#variables">Variables</a></li><li><a href="#terms">Terms</a><ul><li><a href="#afs-terms">AFS Terms</a></li><li><a href="#de-bruijn-terms">de Bruijn Terms</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="function-symbols"><a href="#function-symbols" class="anchor"></a>Function Symbols</h2><div class="odoc-spec"><div class="spec type" id="type-fn" class="anchored"><a href="#type-fn" class="anchor"></a><code><span><span class="keyword">type</span> fn</span></code></div><div class="spec-doc"><p>Abstract type for function symbols.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fn_equal" class="anchored"><a href="#val-fn_equal" class="anchor"></a><code><span><span class="keyword">val</span> fn_equal : <span><a href="#type-fn">fn</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-fn">fn</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>fn_equal f g</code> is whether <code>f</code> and <code>g</code> is structuraly equal</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fn_list" class="anchored"><a href="#val-fn_list" class="anchor"></a><code><span><span class="keyword">val</span> fn_list : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-fn">fn</a> list</span></span></code></div><div class="spec-doc"><p><code>fn_list</code> returns the list of all function symbols names</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_fn" class="anchored"><a href="#val-get_fn" class="anchor"></a><code><span><span class="keyword">val</span> get_fn : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-fn">fn</a></span></code></div><div class="spec-doc"><p><code>fn_from_string name</code> is <code>f</code> if <code>f</code> is registered with name <code>name</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">[Not_found]</span> <p>if there is no such <code>f</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-get_fn_opt" class="anchored"><a href="#val-get_fn_opt" class="anchor"></a><code><span><span class="keyword">val</span> get_fn_opt : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-fn">fn</a> option</span></span></code></div><div class="spec-doc"><p><code>get_fn_opt name</code> is <code>Some f</code> if <code>f</code> is registered with name <code>name</code>, <code>None</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fn_register" class="anchored"><a href="#val-fn_register" class="anchor"></a><code><span><span class="keyword">val</span> fn_register : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-fn">fn</a></span></code></div><div class="spec-doc"><p><code>fn_register f</code> returns a <code>fn</code> with name <code>f</code>.</p><p><b>Side Effect:</b> <code>f</code> is kept in a stack internally.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">DuplicatedName</span> <p>if <code>fn_register f</code> is called for a name <code>f</code> that is already in the stack.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fn_to_string" class="anchored"><a href="#val-fn_to_string" class="anchor"></a><code><span><span class="keyword">val</span> fn_to_string : <span><a href="#type-fn">fn</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>fn_to_string f</code> is the string (name) associated with <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fn_compare" class="anchored"><a href="#val-fn_compare" class="anchor"></a><code><span><span class="keyword">val</span> fn_compare : <span><a href="#type-fn">fn</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-fn">fn</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>fn_compare x y</code> returns <code>0</code> if <code>x</code> is equal to <code>y</code>, a negative integer if <code>x</code> is less than <code>y</code>, and a positive integer if <code>x</code> is greater than <code>y</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fn_register_ty" class="anchored"><a href="#val-fn_register_ty" class="anchor"></a><code><span><span class="keyword">val</span> fn_register_ty : <span><a href="#type-fn">fn</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ty/SType/index.html#type-ty">Ty.SType.ty</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>fn_register_ty f t</code> adds the pair <code>(f, t)</code> to the stack.</p><p><b>Side effect:</b> the list of such pairs <code>(f,t)</code> is kept as state in the terms module.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-arity" class="anchored"><a href="#val-arity" class="anchor"></a><code><span><span class="keyword">val</span> arity : <span><a href="#type-fn">fn</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Ty/SType/index.html#type-ty">Ty.SType.ty</a></span></code></div><div class="spec-doc"><p><code>arity f</code> returns the registered type of <code>f</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Name_not_found</span> <p>if no type is registered for <code>f</code>.</p></li></ul></div></div><h2 id="variables"><a href="#variables" class="anchor"></a>Variables</h2><div class="odoc-spec"><div class="spec type" id="type-var" class="anchored"><a href="#type-var" class="anchor"></a><code><span><span class="keyword">type</span> var</span></code></div><div class="spec-doc"><p>Abstract type for variables.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-var_equal" class="anchored"><a href="#val-var_equal" class="anchor"></a><code><span><span class="keyword">val</span> var_equal : <span><a href="#type-var">var</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-var">var</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>var_equal x y</code> is wheter <code>x</code> is structurally equal to <code>y</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-var_list" class="anchored"><a href="#val-var_list" class="anchor"></a><code><span><span class="keyword">val</span> var_list : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-var">var</a> list</span></span></code></div><div class="spec-doc"><p><code>var_list ()</code> returns the list of all variables registered up to the time this function is called.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_var" class="anchored"><a href="#val-get_var" class="anchor"></a><code><span><span class="keyword">val</span> get_var : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-var">var</a></span></code></div><div class="spec-doc"><p><code>get_var name</code> is the variable <code>v</code> that is registered with the key name <code>name</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Name_not_found</span> <p>if no variable is registered by <code>name</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-get_var_opt" class="anchored"><a href="#val-get_var_opt" class="anchor"></a><code><span><span class="keyword">val</span> get_var_opt : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-var">var</a> option</span></span></code></div><div class="spec-doc"><p><code>get_var_opt name</code> is <code>Some v</code> if <code>v</code> is a variable registered with name key <code>name</code>, and <code>None</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-var_register" class="anchored"><a href="#val-var_register" class="anchor"></a><code><span><span class="keyword">val</span> var_register : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-var">var</a></span></code></div><div class="spec-doc"><p><code>var_register name</code> registers a variable <code>v</code> using the key name <code>name</code>. If such variable is already registered, then no name is registered and the previously recorded name is returned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-var_to_string" class="anchored"><a href="#val-var_to_string" class="anchor"></a><code><span><span class="keyword">val</span> var_to_string : <span><a href="#type-var">var</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>var_to_string x</code> is the written representation of the key value used to register <code>x</code>.</p></div></div><h2 id="terms"><a href="#terms" class="anchor"></a>Terms</h2><p>Finally, given that we have types and functionalities for function symbols and variables, we can construct our type for terms.</p><p>Two notions of terms is defined: the type <a href="#type-term"><code>term</code></a> is for named terms, i.e., variables have names. The second type <a href="#type-bruijn"><code>bruijn</code></a> is an abstract type used to represent terms in de bruijn notation. We instantiate <a href="#type-bruijn"><code>bruijn</code></a> to a concrete implementation <a href="#type-nameless"><code>nameless</code></a>, where function symbols are <a href="#type-fn"><code>fn</code></a> and indeces are integers.</p><h3 id="afs-terms"><a href="#afs-terms" class="anchor"></a>AFS Terms</h3><div class="odoc-spec"><div class="spec type" id="type-term" class="anchored"><a href="#type-term" class="anchor"></a><code><span><span class="keyword">type</span> term</span><span> = </span></code><table><tr id="type-term.Fun" class="anchored"><td class="def variant constructor"><a href="#type-term.Fun" class="anchor"></a><code><span>| </span><span><span class="constructor">Fun</span> <span class="keyword">of</span> <a href="#type-fn">fn</a></span></code></td></tr><tr id="type-term.Var" class="anchored"><td class="def variant constructor"><a href="#type-term.Var" class="anchor"></a><code><span>| </span><span><span class="constructor">Var</span> <span class="keyword">of</span> <a href="#type-var">var</a></span></code></td></tr><tr id="type-term.Lam" class="anchored"><td class="def variant constructor"><a href="#type-term.Lam" class="anchor"></a><code><span>| </span><span><span class="constructor">Lam</span> <span class="keyword">of</span> <a href="#type-var">var</a> * <a href="#type-term">term</a></span></code></td></tr><tr id="type-term.App" class="anchored"><td class="def variant constructor"><a href="#type-term.App" class="anchor"></a><code><span>| </span><span><span class="constructor">App</span> <span class="keyword">of</span> <a href="#type-term">term</a> * <a href="#type-term">term</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Type for terms.</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-tm_to_string" class="anchored"><a href="#val-tm_to_string" class="anchor"></a><code><span><span class="keyword">val</span> tm_to_string : <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>tm_to_string t</code> is the written representation of <code>t</code>. It uses standard rules to generate the strings, so unecessary parenthesis are removed:</p><ul><li>application is left associative</li><li>application has precedence over abstraction</li><li>abstraction is right-associative</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-free_var" class="anchored"><a href="#val-free_var" class="anchor"></a><code><span><span class="keyword">val</span> free_var : <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-var">var</a> list</span></span></code></div><div class="spec-doc"><p><code>free_var t</code> return the list of free variables in <code>t</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-term_equal" class="anchored"><a href="#val-term_equal" class="anchor"></a><code><span><span class="keyword">val</span> term_equal : <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>term_equal t t'</code> is whether <code>t</code> and <code>t'</code> are equal module alpha-equivalence.</p></div></div><h3 id="de-bruijn-terms"><a href="#de-bruijn-terms" class="anchor"></a>de Bruijn Terms</h3><p>In de Bruijn notation, variables are nameless, i.e., they are represented by numbers.</p><p>In a closed term, the indexes represent the distance of a variable to its binding abstractor. If the original term <code>t</code> has free variables, then we need a naming context to represent <code>t</code> as a nameless term.</p><div class="odoc-spec"><div class="spec type" id="type-bruijn" class="anchored"><a href="#type-bruijn" class="anchor"></a><code><span><span class="keyword">type</span> <span>('f, 'v) bruijn</span></span><span> = </span></code><table><tr id="type-bruijn.NFun" class="anchored"><td class="def variant constructor"><a href="#type-bruijn.NFun" class="anchor"></a><code><span>| </span><span><span class="constructor">NFun</span> <span class="keyword">of</span> <span class="type-var">'f</span></span></code></td></tr><tr id="type-bruijn.NVar" class="anchored"><td class="def variant constructor"><a href="#type-bruijn.NVar" class="anchor"></a><code><span>| </span><span><span class="constructor">NVar</span> <span class="keyword">of</span> <span class="type-var">'v</span></span></code></td></tr><tr id="type-bruijn.NLam" class="anchored"><td class="def variant constructor"><a href="#type-bruijn.NLam" class="anchor"></a><code><span>| </span><span><span class="constructor">NLam</span> <span class="keyword">of</span> <span><span>( <span class="type-var">'f</span>, <span class="type-var">'v</span> )</span> <a href="#type-bruijn">bruijn</a></span></span></code></td></tr><tr id="type-bruijn.NApp" class="anchored"><td class="def variant constructor"><a href="#type-bruijn.NApp" class="anchor"></a><code><span>| </span><span><span class="constructor">NApp</span> <span class="keyword">of</span> <span><span>( <span class="type-var">'f</span>, <span class="type-var">'v</span> )</span> <a href="#type-bruijn">bruijn</a></span> * <span><span>( <span class="type-var">'f</span>, <span class="type-var">'v</span> )</span> <a href="#type-bruijn">bruijn</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Abstract type for de Bruijn term representation.</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-nameless" class="anchored"><a href="#type-nameless" class="anchor"></a><code><span><span class="keyword">type</span> nameless</span><span> = <span><span>( <a href="#type-fn">fn</a>, int )</span> <a href="#type-bruijn">bruijn</a></span></span></code></div><div class="spec-doc"><p>Concrete instantiation of <a href="#type-bruijn"><code>bruijn</code></a> type. Function symbols are <a href="#type-fn"><code>fn</code></a> and variables (indices) are integers.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-terms_to_bruijn" class="anchored"><a href="#val-terms_to_bruijn" class="anchor"></a><code><span><span class="keyword">val</span> terms_to_bruijn : <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-nameless">nameless</a></span></code></div><div class="spec-doc"><p><code>terms_to_bruijn t</code> returns the nameless representation of <code>t</code>, it uses the set of free-variables of <code>t</code> as the name context to determine the index of free variables.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-terms_to_bruijn_ctx" class="anchored"><a href="#val-terms_to_bruijn_ctx" class="anchor"></a><code><span><span class="keyword">val</span> terms_to_bruijn_ctx : <span><span><a href="#type-var">var</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-nameless">nameless</a></span></code></div><div class="spec-doc"><p><code>terms_to_bruijn_ctx ctx t</code> returns the nameless representation of <code>t</code>; but contrary to <a href="#val-terms_to_bruijn"><code>terms_to_bruijn</code></a>, it uses the context <code>ctx</code> to determine the position of the free variables in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-nameless_to_string" class="anchored"><a href="#val-nameless_to_string" class="anchor"></a><code><span><span class="keyword">val</span> nameless_to_string : <span><a href="#type-nameless">nameless</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>nameless_to_string n</code> returns the string representation of the nameless term <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-nameless_equal" class="anchored"><a href="#val-nameless_equal" class="anchor"></a><code><span><span class="keyword">val</span> nameless_equal : <span><a href="#type-nameless">nameless</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-nameless">nameless</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>nameless_equal n n'</code> is whether <code>n</code> and <code>n'</code> are syntactically equal.</p><p><b>Note:</b> syntactical equality of two nameless terms imply in alpha-equality. Therefore, if <code>t,t'</code> are values of type <a href="#type-term"><code>term</code></a>, then <code>t</code> is alpha-equivalent to <code>t'</code> iff</p><p><code>nameless_equal (terms_to_bruijn t) (terms_to_bruijn t') </code></p><p>evaluates to <code>true</code>.</p></div></div></div></body></html>